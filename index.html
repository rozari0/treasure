<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BCI 3D Maze Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        #gameUI {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
            font-size: 18px;
        }
        #wsStatus {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 10;
        }
        .ws-connected {
            background-color: rgba(34, 197, 94, 0.8);
            color: white;
        }
        .ws-disconnected {
            background-color: rgba(239, 68, 68, 0.8);
            color: white;
        }
        .ws-connecting {
            background-color: rgba(251, 191, 36, 0.8);
            color: black;
        }
    </style>
</head>
<body>
    <div id="wsStatus" class="ws-disconnected">WebSocket: Disconnected</div>
    <div id="gameUI">
        <div>Score: <span id="score">0</span></div>
        <div>Treasures: <span id="treasures">0</span></div>
        <div>Obstacles Removed: <span id="obstacles">0</span></div>
        <div style="margin-top: 10px; font-size: 14px;">
            <div>Movement: <span id="debugMove">0</span></div>
            <div>Rotation: <span id="debugRotate">0</span></div>
        </div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============================================
        // GAME CONFIG
        // ============================================
        const GAME_CONFIG = {
            MAZE_SIZE: 10,
            CELL_SIZE: 10,
            WALL_HEIGHT: 5,
            WALL_THICKNESS: 0.5,
            PLAYER_HEIGHT: 2,
            PLAYER_SPEED: 0.2,       // Increased for better control
            ROTATION_SPEED: 0.1,     // Increased for better control
            TREASURE_COUNT: 10,      // More treasures
            WS_URL: 'ws://127.0.0.1:8000/ws',
            WS_RECONNECT_DELAY: 3000
        };

        // ============================================
        // GAME STATE
        // ============================================
        const gameState = {
            score: 0,
            treasuresCollected: 0,
            obstaclesRemoved: 0
        };

        // ============================================
        // PLAYER STATE
        // ============================================
        const player = {
            position: { x: 0, z: 0 },
              rotation: 0
        };

           // Command queue system
           const commandQueue = [];
           let isExecutingCommand = false;

        // ============================================
        // WEBSOCKET STATE
        // ============================================
        let ws = null;
        let wsReconnectTimeout = null;

        // ============================================
        // THREE.JS SCENE SETUP
        // ============================================
        let scene, camera, renderer;
        let maze = [];
        let treasures = [];
        let paintedCellMeshes = new Map();

        function initThreeJS() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 100);

            // Camera (first-person view)
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.y = GAME_CONFIG.PLAYER_HEIGHT;

            // Renderer
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameCanvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(
                GAME_CONFIG.MAZE_SIZE * GAME_CONFIG.CELL_SIZE,
                GAME_CONFIG.MAZE_SIZE * GAME_CONFIG.CELL_SIZE
            );
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Window resize handler
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============================================
        // MAZE GENERATION
        // ============================================
        function generateMaze() {
            // Simple maze: grid with some walls
            const size = GAME_CONFIG.MAZE_SIZE;
            maze = Array(size).fill(null).map(() => Array(size).fill(0));

            // Create outer walls
            for (let i = 0; i < size; i++) {
                maze[0][i] = 1;
                maze[size - 1][i] = 1;
                maze[i][0] = 1;
                maze[i][size - 1] = 1;
            }

            // Create some internal walls randomly
            for (let i = 2; i < size - 2; i += 2) {
                for (let j = 2; j < size - 2; j += 2) {
                    if (Math.random() > 0.3) {
                        maze[i][j] = 1;
                        // Add some adjacent walls
                        const dir = Math.floor(Math.random() * 4);
                        if (dir === 0 && i > 0) maze[i - 1][j] = 1;
                        else if (dir === 1 && i < size - 1) maze[i + 1][j] = 1;
                        else if (dir === 2 && j > 0) maze[i][j - 1] = 1;
                        else if (dir === 3 && j < size - 1) maze[i][j + 1] = 1;
                    }
                }
            }

            // Ensure starting position is clear
            maze[5][5] = 0;
            if (maze[4]) maze[4][5] = 0;
            if (maze[5]) maze[5][4] = 0;
        }

        function buildMazeWalls() {
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const size = GAME_CONFIG.MAZE_SIZE;

            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    if (maze[i][j] === 1) {
                        const wallGeometry = new THREE.BoxGeometry(
                            GAME_CONFIG.CELL_SIZE,
                            GAME_CONFIG.WALL_HEIGHT,
                            GAME_CONFIG.CELL_SIZE
                        );
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        
                        // Position in world coordinates
                        wall.position.x = (j - size / 2) * GAME_CONFIG.CELL_SIZE;
                        wall.position.y = GAME_CONFIG.WALL_HEIGHT / 2;
                        wall.position.z = (i - size / 2) * GAME_CONFIG.CELL_SIZE;
                        
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        wall.userData.isWall = true;
                        scene.add(wall);
                    }
                }
            }
        }

        // ============================================
        // TREASURE SYSTEM
        // ============================================
        function spawnTreasures() {
            const treasureMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFD700,
                emissive: 0xFFD700,
                emissiveIntensity: 0.5,
                metalness: 0.8,
                roughness: 0.2
            });

            const size = GAME_CONFIG.MAZE_SIZE;
            let spawned = 0;

            while (spawned < GAME_CONFIG.TREASURE_COUNT) {
                const i = Math.floor(Math.random() * (size - 2)) + 1;
                const j = Math.floor(Math.random() * (size - 2)) + 1;

                // Only spawn on empty cells
                if (maze[i][j] === 0 && !(i === 5 && j === 5)) {
                    const treasureGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                    const treasure = new THREE.Mesh(treasureGeometry, treasureMaterial);
                    
                    treasure.position.x = (j - size / 2) * GAME_CONFIG.CELL_SIZE;
                    treasure.position.y = 1;
                    treasure.position.z = (i - size / 2) * GAME_CONFIG.CELL_SIZE;
                    
                    treasure.castShadow = true;
                    treasure.userData.isTreasure = true;
                    treasure.userData.gridPos = { i, j };
                    
                    scene.add(treasure);
                    treasures.push(treasure);
                    spawned++;
                }
            }
        }

        function getDistance(x1, z1, x2, z2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(z2 - z1, 2));
        }

        function pickUpTreasure() {
            const pickupRange = 2; // Units in world space
            
            for (let i = treasures.length - 1; i >= 0; i--) {
                const treasure = treasures[i];
                const distance = getDistance(
                    player.position.x,
                    player.position.z,
                    treasure.position.x,
                    treasure.position.z
                );
                
                if (distance <= pickupRange) {
                    scene.remove(treasure);
                    treasures.splice(i, 1);
                    
                    gameState.treasuresCollected++;
                    gameState.score += 100;
                    updateUI();
                    
                    console.log(`Treasure collected! Total: ${gameState.treasuresCollected}`);
                    return;
                }
            }
            console.log('No treasure within range');
        }

        // ============================================
        // OBSTACLE SYSTEM
        // ============================================
        let obstacles = [];

        function spawnObstacles() {
            const obstacleGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const obstacleMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF4444,
                metalness: 0.7,
                roughness: 0.3,
                emissive: 0x441111
            });

            const size = GAME_CONFIG.MAZE_SIZE;
            const obstacleCount = Math.floor(size * size * 0.1); // 10% of maze cells

            for (let i = 0; i < obstacleCount; i++) {
                const x = Math.floor(Math.random() * (size - 2)) + 1;
                const z = Math.floor(Math.random() * (size - 2)) + 1;

                // Don't spawn on walls, treasures, or starting position
                if (maze[z][x] === 0 && !(x === 5 && z === 5)) {
                    const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                    
                    obstacle.position.x = (x - size / 2) * GAME_CONFIG.CELL_SIZE;
                    obstacle.position.y = 0.75;
                    obstacle.position.z = (z - size / 2) * GAME_CONFIG.CELL_SIZE;
                    
                    obstacle.castShadow = true;
                    obstacle.receiveShadow = true;
                    obstacle.userData.isObstacle = true;
                    
                    scene.add(obstacle);
                    obstacles.push(obstacle);
                }
            }
        }

        function removeNearbyObstacle() {
            const interactionRange = 2.5; // Units in world space
            
            let nearestDistance = Infinity;
            let nearestObstacle = null;
            let nearestIndex = -1;

            // Find the nearest obstacle within range
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                const distance = getDistance(
                    player.position.x,
                    player.position.z,
                    obstacle.position.x,
                    obstacle.position.z
                );
                
                if (distance < nearestDistance) {
                    nearestDistance = distance;
                    nearestObstacle = obstacle;
                    nearestIndex = i;
                }
            }
            
            // Remove the nearest obstacle if it's within range
            if (nearestObstacle && nearestDistance <= interactionRange) {
                // Create a quick fade-out effect
                const opacity = { value: 1 };
                const fadeOutDuration = 200; // milliseconds

                const tween = {
                    start: Date.now(),
                    animate: function() {
                        const elapsed = Date.now() - this.start;
                        const progress = Math.min(elapsed / fadeOutDuration, 1);
                        
                        nearestObstacle.material.opacity = 1 - progress;
                        
                        if (progress < 1) {
                            requestAnimationFrame(() => this.animate());
                        } else {
                            // Remove the obstacle after fade-out
                            scene.remove(nearestObstacle);
                            obstacles.splice(nearestIndex, 1);
                        }
                    }
                };

                // Make the material transparent for fade-out
                nearestObstacle.material.transparent = true;
                tween.animate();
                
                // Update game state
                gameState.obstaclesRemoved++;
                gameState.score += 50;
                updateUI();
                
                console.log(`Obstacle destroyed! Total: ${gameState.obstaclesRemoved}`);
            } else {
                console.log('No obstacle within range');
            }
        }

        // ============================================
        // COLLISION DETECTION
        // ============================================
        function worldToGrid(worldX, worldZ) {
            const size = GAME_CONFIG.MAZE_SIZE;
            const j = Math.floor(worldX / GAME_CONFIG.CELL_SIZE + size / 2);
            const i = Math.floor(worldZ / GAME_CONFIG.CELL_SIZE + size / 2);
            return { i, j };
        }

        function checkCollision(newX, newZ) {
            const cell = worldToGrid(newX, newZ);
            
            // Check bounds
            if (cell.i < 0 || cell.i >= GAME_CONFIG.MAZE_SIZE ||
                cell.j < 0 || cell.j >= GAME_CONFIG.MAZE_SIZE) {
                return true;
            }
            
            // Check wall collision
            if (maze[cell.i][cell.j] === 1) {
                return true;
            }
            
            return false;
        }

        // ============================================
        // MOVEMENT CONTROL FUNCTIONS
        // ============================================
            function queueCommand(command) {
                commandQueue.push(command);
                console.log(`Command queued: ${command}, Queue length: ${commandQueue.length}`);
        }

            function executeNextCommand() {
                if (isExecutingCommand || commandQueue.length === 0) {
                    return;
                }

                isExecutingCommand = true;
                const command = commandQueue.shift();
                console.log(`Executing command: ${command}, Remaining in queue: ${commandQueue.length}`);

                switch (command) {
                    case 'up':
                        executeMoveForward();
                        break;
                    case 'down':
                        executeMoveBackward();
                        break;
                    case 'left':
                        executeRotateLeft();
                        break;
                    case 'right':
                        executeRotateRight();
                        break;
                    case 'pull':
                        pickUpTreasure();
                        isExecutingCommand = false;  // Instant action, no delay needed
                        break;
                    case 'push':
                        removeNearbyObstacle();
                        isExecutingCommand = false;  // Instant action, no delay needed
                        break;
                    case 'stop':
                        commandQueue.length = 0;  // Clear queue
                        isExecutingCommand = false;
                        console.log('Queue cleared');
                        break;
                    default:
                        console.warn(`Unknown command: "${command}"`);
                        isExecutingCommand = false;
                        break;
                }
        }

            function executeMoveForward() {
                const moveSpeed = GAME_CONFIG.PLAYER_SPEED;
                const newX = player.position.x + Math.sin(player.rotation) * moveSpeed;
                const newZ = player.position.z + Math.cos(player.rotation) * moveSpeed;

                if (!checkCollision(newX, newZ)) {
                    player.position.x = newX;
                    player.position.z = newZ;
                    console.log('Moved forward');
                } else {
                    console.log('Forward movement blocked by collision');
                }
                isExecutingCommand = false;
            }

            function executeMoveBackward() {
                const moveSpeed = -GAME_CONFIG.PLAYER_SPEED;
                const newX = player.position.x + Math.sin(player.rotation) * moveSpeed;
                const newZ = player.position.z + Math.cos(player.rotation) * moveSpeed;

                if (!checkCollision(newX, newZ)) {
                    player.position.x = newX;
                    player.position.z = newZ;
                    console.log('Moved backward');
                } else {
                    console.log('Backward movement blocked by collision');
                }
                isExecutingCommand = false;
            }

            function executeRotateLeft() {
                player.rotation -= GAME_CONFIG.ROTATION_SPEED;
                console.log('Rotated left');
                isExecutingCommand = false;
            }

            function executeRotateRight() {
                player.rotation += GAME_CONFIG.ROTATION_SPEED;
                console.log('Rotated right');
                isExecutingCommand = false;
        }

        // ============================================
        // PLAYER INPUT PROCESSING
        // ============================================
        function processPlayerInput() {
                // Try to execute the next command in the queue
                executeNextCommand();
            
                // Update debug UI with queue length
                document.getElementById('debugMove').textContent = commandQueue.length;
                document.getElementById('debugRotate').textContent = isExecutingCommand ? '1' : '0';
        }

        // ============================================
        // MOVEMENT UPDATE
        // ============================================
        function updateMovement() {
            // Update camera position and rotation
            camera.position.x = player.position.x;
            camera.position.z = player.position.z;
            camera.rotation.y = player.rotation;
        }

        // ============================================
        // WEBSOCKET SETUP
        // ============================================
        function setupWebSocket() {
            // Clear any existing reconnect timeout
            if (wsReconnectTimeout) {
                clearTimeout(wsReconnectTimeout);
                wsReconnectTimeout = null;
            }

            console.log(`Connecting to WebSocket: ${GAME_CONFIG.WS_URL}`);
            updateWSStatus('connecting');

            try {
                ws = new WebSocket(GAME_CONFIG.WS_URL);

                ws.onopen = () => {
                    console.log('WebSocket connected successfully');
                    updateWSStatus('connected');
                };

                ws.onmessage = (event) => {
                    const command = event.data.trim().toLowerCase();
                    console.log(`WebSocket command received: "${command}"`);

                        // Queue all commands for sequential execution
                        queueCommand(command);
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateWSStatus('disconnected');
                };

                ws.onclose = () => {
                    console.log('WebSocket closed. Attempting to reconnect...');
                    updateWSStatus('disconnected');
                    ws = null;
                    
                    // Attempt to reconnect after delay
                    wsReconnectTimeout = setTimeout(() => {
                        setupWebSocket();
                    }, GAME_CONFIG.WS_RECONNECT_DELAY);
                };
            } catch (error) {
                console.error('Failed to create WebSocket:', error);
                updateWSStatus('disconnected');
                
                // Retry connection
                wsReconnectTimeout = setTimeout(() => {
                    setupWebSocket();
                }, GAME_CONFIG.WS_RECONNECT_DELAY);
            }
        }

        function updateWSStatus(status) {
            const statusDiv = document.getElementById('wsStatus');
            statusDiv.className = '';
            
            switch (status) {
                case 'connected':
                    statusDiv.textContent = 'WebSocket: Connected';
                    statusDiv.classList.add('ws-connected');
                    break;
                case 'disconnected':
                    statusDiv.textContent = 'WebSocket: Disconnected';
                    statusDiv.classList.add('ws-disconnected');
                    break;
                case 'connecting':
                    statusDiv.textContent = 'WebSocket: Connecting...';
                    statusDiv.classList.add('ws-connecting');
                    break;
            }
        }

        // ============================================
        // UI UPDATES
        // ============================================
        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('treasures').textContent = gameState.treasuresCollected;
            document.getElementById('obstacles').textContent = gameState.obstaclesRemoved;
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================
        function animate() {
            requestAnimationFrame(animate);

            // Process player input (updates debug UI only, doesn't reset directions)
            processPlayerInput();

            // Update movement based on persistent direction state
            updateMovement();

            // Render the scene
            renderer.render(scene, camera);
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            console.log('Initializing BCI 3D Maze Game...');

            // Initialize Three.js
            initThreeJS();

            // Generate and build maze
            generateMaze();
            buildMazeWalls();

            // Spawn treasures and obstacles
            spawnTreasures();
            spawnObstacles();

            // Set initial player position
            player.position.x = 0;
            player.position.z = 0;
            player.rotation = 0;
            camera.position.x = player.position.x;
            camera.position.z = player.position.z;

            // Update UI
            updateUI();

            // Setup WebSocket
            setupWebSocket();

            // Start animation loop
            animate();

            console.log('Game initialized successfully!');
            console.log('Waiting for WebSocket commands...');
            console.log('Commands: up, down, left, right, stop, pull, push');
        }

        // ============================================
        // KEYBOARD CONTROLS
        // ============================================
        function setupKeyboardControls() {
            window.addEventListener('keydown', (event) => {
                // Prevent default behavior for game control keys
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'p', 'P'].includes(event.key)) {
                    event.preventDefault();
                }

                // Only process if not being held down
                if (event.repeat) return;

                switch (event.key) {
                    case 'ArrowUp':
                        queueCommand('up');
                        break;
                    case 'ArrowDown':
                        queueCommand('down');
                        break;
                    case 'ArrowLeft':
                        queueCommand('left');
                        break;
                    case 'ArrowRight':
                        queueCommand('right');
                        break;
                    case ' ':  // Spacebar
                        queueCommand('pull');
                        break;
                    case 'p':
                    case 'P':
                        queueCommand('push');
                        break;
                }
            });
        }

        // Start the game when page loads
        window.addEventListener('DOMContentLoaded', () => {
            init();
            setupKeyboardControls();
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (ws) {
                ws.close();
            }
            if (wsReconnectTimeout) {
                clearTimeout(wsReconnectTimeout);
            }
        });
    </script>
</body>
</html>
